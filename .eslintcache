[{"/Users/awesomeinc/ainc/lightbot/src/index.js":"1","/Users/awesomeinc/ainc/lightbot/src/reportWebVitals.js":"2","/Users/awesomeinc/ainc/lightbot/src/components/App.js":"3","/Users/awesomeinc/ainc/lightbot/src/utilities/AppContext.js":"4","/Users/awesomeinc/ainc/lightbot/src/components/Home.js":"5","/Users/awesomeinc/ainc/lightbot/src/components/Footer.js":"6","/Users/awesomeinc/ainc/lightbot/src/components/Sections.js":"7","/Users/awesomeinc/ainc/lightbot/src/components/Levels.js":"8","/Users/awesomeinc/ainc/lightbot/src/components/Navbar.js":"9","/Users/awesomeinc/ainc/lightbot/src/data/sectionData.js":"10","/Users/awesomeinc/ainc/lightbot/src/data/levelData.js":"11","/Users/awesomeinc/ainc/lightbot/src/components/sprites/Cube.js":"12","/Users/awesomeinc/ainc/lightbot/src/components/sprites/Robot.js":"13","/Users/awesomeinc/ainc/lightbot/src/components/sprites/CodeBlock.js":"14","/Users/awesomeinc/ainc/lightbot/src/data/index.js":"15","/Users/awesomeinc/ainc/lightbot/src/components/Modal.js":"16","/Users/awesomeinc/ainc/lightbot/src/components/Game.js":"17","/Users/awesomeinc/ainc/lightbot/src/components/sprites/ForwardBlock.js":"18","/Users/awesomeinc/ainc/lightbot/src/components/sprites/LeftBlock.js":"19","/Users/awesomeinc/ainc/lightbot/src/components/sprites/RightBlock.js":"20","/Users/awesomeinc/ainc/lightbot/src/components/sprites/LightBlock.js":"21","/Users/awesomeinc/ainc/lightbot/src/components/sprites/SpringBlock.js":"22"},{"size":640,"mtime":1608226836539,"results":"23","hashOfConfig":"24"},{"size":362,"mtime":1608222573336,"results":"25","hashOfConfig":"24"},{"size":1005,"mtime":1611696494114,"results":"26","hashOfConfig":"24"},{"size":502,"mtime":1608224935590,"results":"27","hashOfConfig":"24"},{"size":319,"mtime":1608236851515,"results":"28","hashOfConfig":"24"},{"size":242,"mtime":1608236845347,"results":"29","hashOfConfig":"24"},{"size":1129,"mtime":1608576894982,"results":"30","hashOfConfig":"24"},{"size":1163,"mtime":1608581728089,"results":"31","hashOfConfig":"24"},{"size":1164,"mtime":1608580858652,"results":"32","hashOfConfig":"24"},{"size":305,"mtime":1608576900555,"results":"33","hashOfConfig":"24"},{"size":7174,"mtime":1611768607066,"results":"34","hashOfConfig":"24"},{"size":3743,"mtime":1611606425876,"results":"35","hashOfConfig":"24"},{"size":923,"mtime":1611601847639,"results":"36","hashOfConfig":"24"},{"size":1999,"mtime":1611775869631,"results":"37","hashOfConfig":"24"},{"size":541,"mtime":1611601837729,"results":"38","hashOfConfig":"24"},{"size":1955,"mtime":1611697064061,"results":"39","hashOfConfig":"24"},{"size":28464,"mtime":1611778850144,"results":"40","hashOfConfig":"24"},{"size":1211,"mtime":1611770087887,"results":"41","hashOfConfig":"24"},{"size":1824,"mtime":1611770960193,"results":"42","hashOfConfig":"24"},{"size":1849,"mtime":1611771201598,"results":"43","hashOfConfig":"24"},{"size":2393,"mtime":1611773853701,"results":"44","hashOfConfig":"24"},{"size":1390,"mtime":1611775250258,"results":"45","hashOfConfig":"24"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},"1piam7y",{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"59"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"59"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"59"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"59"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"59"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"80","messages":"81","errorCount":1,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"82","usedDeprecatedRules":"48"},{"filePath":"83","messages":"84","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"85","messages":"86","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"89","messages":"90","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"91","messages":"92","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/awesomeinc/ainc/lightbot/src/index.js",[],["93","94"],"/Users/awesomeinc/ainc/lightbot/src/reportWebVitals.js",[],"/Users/awesomeinc/ainc/lightbot/src/components/App.js",[],"/Users/awesomeinc/ainc/lightbot/src/utilities/AppContext.js",[],"/Users/awesomeinc/ainc/lightbot/src/components/Home.js",[],"/Users/awesomeinc/ainc/lightbot/src/components/Footer.js",[],["95","96"],"/Users/awesomeinc/ainc/lightbot/src/components/Sections.js",[],"/Users/awesomeinc/ainc/lightbot/src/components/Levels.js",[],"/Users/awesomeinc/ainc/lightbot/src/components/Navbar.js",[],"/Users/awesomeinc/ainc/lightbot/src/data/sectionData.js",[],"/Users/awesomeinc/ainc/lightbot/src/data/levelData.js",[],"/Users/awesomeinc/ainc/lightbot/src/components/sprites/Cube.js",[],"/Users/awesomeinc/ainc/lightbot/src/components/sprites/Robot.js",[],"/Users/awesomeinc/ainc/lightbot/src/components/sprites/CodeBlock.js",[],"/Users/awesomeinc/ainc/lightbot/src/data/index.js",[],"/Users/awesomeinc/ainc/lightbot/src/components/Modal.js",[],"/Users/awesomeinc/ainc/lightbot/src/components/Game.js",["97","98","99","100","101","102","103","104"],"import { useState, useMemo, Fragment } from 'react'\r\nimport { useParams, Redirect } from 'react-router-dom'\r\nimport { Stage, Layer, Text, Rect, Line } from 'react-konva'\r\nimport CodeBlock from './sprites/CodeBlock'\r\nimport Cube from './sprites/Cube'\r\nimport Robot from './sprites/Robot'\r\nimport Modal from './Modal'\r\nimport { sections } from '../data/sectionData'\r\nimport { levels } from '../data/levelData'\r\nimport { colors, blockSize, moveTypes, blockTypes } from '../data'\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { useWindowSize } from '@react-hook/window-size'\r\nimport ForwardBlock from './sprites/ForwardBlock'\r\nimport LeftBlock from './sprites/LeftBlock'\r\nimport RightBlock from './sprites/RightBlock'\r\nimport LightBlock from './sprites/LightBlock'\r\nimport SpringBlock from './sprites/SpringBlock'\r\n\r\nfunction Game() {\r\n\r\n    // TODO: abstract each component to a new file\r\n    // modal related\r\n    const [modal, setModal] = useState(false);\r\n    const toggleModal = () => setModal(!modal);\r\n\r\n    const { sectionName, levelID } = useParams()\r\n    const section = sections.find(section => section.name === sectionName)\r\n    const foundLevel = !!section\r\n        ? levels.find(l => l.section_id === section.id && l.level_id === parseInt(levelID))\r\n        : undefined\r\n    const legalLevel = !!section && !!foundLevel\r\n    const [levelData, setLevelData] = useState(!!foundLevel ? foundLevel.level_data : [])\r\n    const resetLevel = () => setLevelData(p => {\r\n        // TODO: bug - on reset game, the colors dont go back to blue for the light tiles\r\n        // TODO: bug - on redo or continue in modal, the board does not re render and the blocks stay in the code pen\r\n        const correctData = !!foundLevel ? foundLevel.level_data : []\r\n        return [...correctData]\r\n    })\r\n    const [robotLocation, setRobotLocation] = useState(!!foundLevel ? foundLevel.renderRobot : {})\r\n    const [width, height] = useWindowSize()\r\n    const resetRobot = () => setRobotLocation(!!foundLevel ? foundLevel.renderRobot : {})\r\n    const offsetX = width - 480;\r\n    const offsetY = 20;\r\n    const [timeInterval, setTimeInterval] = useState(500)\r\n    const updateTimeInterval = () => setTimeInterval(pTime => pTime === 500 ? 250 : 500)\r\n    // create Level layers for robot\r\n    const renderLevel = () => {\r\n        const renderedLevel = levelData.map((block, index) => {\r\n            return Array(block.z).fill().map((item, layer) => {\r\n                return (\r\n                    <Cube\r\n                        {...block}\r\n                        x={block.x}\r\n                        y={block.y}\r\n                        z={layer}\r\n                        // update block color if robot lights correct block\r\n                        type={block.type}\r\n\r\n                        key={`${index}-${layer}`}\r\n                    />\r\n                )\r\n            })\r\n        })\r\n        return (\r\n            <Layer>\r\n                {/* robot level layer */}\r\n                {renderedLevel.length > 0 ?\r\n                    <>\r\n                        {renderedLevel}\r\n                        <Robot {...robotLocation} />\r\n                    </>\r\n                    : <Text text=\"Level not found\" />\r\n                }\r\n            </Layer>\r\n        )\r\n    }\r\n    const memoizedLevel = useMemo(renderLevel, [robotLocation, levelData])\r\n    const [activeGridLayer, setActiveGridLayer] = useState(0)\r\n    // create Grid Layers for block placement\r\n    const createGridLayer = ({ rows, cols, title, position }) => {\r\n        const mainBlockPlacementGridLines_Horizontal = [];\r\n        const mainBlockPlacementGridLines_Vertical = [];\r\n        const gridWidth = cols * blockSize;\r\n        const gridHeight = rows * blockSize;\r\n\r\n        // horizontal lines\r\n        for (let i = 0; i <= rows; i++) {\r\n            mainBlockPlacementGridLines_Horizontal.push(<Line\r\n                strokeWidth={2}\r\n                stroke={\"black\"}\r\n                key={i}\r\n                points={[\r\n                    offsetX + 0,\r\n                    (position * (gridHeight + 110)) + offsetY + i * blockSize,\r\n                    offsetX + gridWidth,\r\n                    (position * (gridHeight + 110)) + offsetY + i * blockSize\r\n                ]}\r\n            />)\r\n        }\r\n        // vertical lines\r\n        for (let i = 0; i <= cols; i++) {\r\n            mainBlockPlacementGridLines_Vertical.push(<Line\r\n                strokeWidth={2}\r\n                key={i}\r\n                stroke={\"black\"}\r\n                points={[\r\n                    offsetX + blockSize * i,\r\n                    (position * (gridHeight + 110)) + offsetY + 0,\r\n                    offsetX + blockSize * i,\r\n                    (position * (gridHeight + 110)) + offsetY + gridHeight\r\n                ]}\r\n            />)\r\n        }\r\n        return (\r\n            <Layer onClick={e => setActiveGridLayer(position)}>\r\n                <Rect\r\n                    x={offsetX - 10}\r\n                    y={(position * (gridHeight + 110)) + offsetY - 20}\r\n                    width={blockSize + 10}\r\n                    height={gridHeight + 30}\r\n                    cornerRadius={2}\r\n                    fill={position === activeGridLayer ? colors.lightYellow : colors.lightGrey} />\r\n                <Rect\r\n                    x={offsetX - 10}\r\n                    y={(position * (gridHeight + 110)) + offsetY - 10}\r\n                    width={gridWidth + 20}\r\n                    height={gridHeight + 20}\r\n                    cornerRadius={2}\r\n                    fill={position === activeGridLayer ? colors.lightYellow : colors.lightGrey} />\r\n                <Text text={title} x={offsetX} y={(position * (gridHeight + 110)) + (offsetY / 4)} />\r\n                {mainBlockPlacementGridLines_Horizontal}\r\n                {mainBlockPlacementGridLines_Vertical}\r\n            </Layer>\r\n        )\r\n    }\r\n    const memoizedMainGrid = useMemo(() => createGridLayer({ rows: 3, cols: 4, title: \"Main\", position: 0 }), [activeGridLayer])\r\n\r\n    const memoizedFuncGrid = useMemo(() => createGridLayer({ rows: 2, cols: 4, title: \"Function 1\", position: 1 }), [activeGridLayer])\r\n    const [mainBlocks, setMainBlocks] = useState([])\r\n    const [func1Blocks, setFunc1Blocks] = useState([])\r\n    // block related\r\n    const createNewBlock = (e, blockType) => {\r\n        resetRobot()\r\n        resetLevel()\r\n        // TODO: broken, need to fix this\r\n        //  TODO: add func 1 blocks\r\n        if (activeGridLayer === 0) {\r\n            setMainBlocks(prevMainBlocks => {\r\n                if (prevMainBlocks.length >= 12) {\r\n                    console.log('too many blocks')\r\n                    return prevMainBlocks\r\n                }\r\n                // calculate location for next block\r\n                const areaType = activeGridLayer\r\n                const i = (prevMainBlocks.length % 4)\r\n                const j = Math.floor(prevMainBlocks.length / 4)\r\n                const id = uuidv4()\r\n                const order = prevMainBlocks.length\r\n                const newBlock = { id, i, j, blockType, areaType, order }\r\n                return [...prevMainBlocks, newBlock]\r\n            })\r\n        }\r\n        else if (activeGridLayer === 1) {\r\n            setFunc1Blocks(prevFunc1Blocks => {\r\n                if (prevFunc1Blocks.length >= 12) {\r\n                    console.log('too many blocks')\r\n                    return prevFunc1Blocks\r\n                }\r\n                // calculate location for next block\r\n                const areaType = activeGridLayer\r\n                const i = (prevFunc1Blocks.length % 4)\r\n                const j = Math.floor(prevFunc1Blocks.length / 4)\r\n                const id = uuidv4()\r\n                const order = prevFunc1Blocks.length\r\n                const newBlock = { id, i, j, blockType, areaType, order }\r\n                return [...prevFunc1Blocks, newBlock]\r\n            })\r\n        }\r\n    }\r\n    // block x,y,i,j calculation\r\n    const calcX = (i) => offsetX + (i * blockSize)\r\n    const calcY = (j,p) => offsetY + (j * blockSize) + (p * j + 110)\r\n    const calcI = (x) => (x - offsetX) / blockSize\r\n    const calcJ = (y,p) => (y - offsetY) / blockSize + (p * j+ 110)\r\n    const Y_Block_selectOffsetRename = 450\r\n    const createMoveSelection = (available_moves) => {\r\n        const moveSelection = available_moves.map((move, index) => {\r\n            return (\r\n                <Fragment key={index}>\r\n                    <Rect\r\n                        onClick={e => createNewBlock(e, move)}\r\n                        x={blockSize * index}\r\n                        y={Y_Block_selectOffsetRename}\r\n                        width={blockSize}\r\n                        height={blockSize}\r\n                        fill={colors.grey}\r\n                        strokeWidth={2}\r\n                        stroke={\"black\"}\r\n                    // handleDragStart={e=>createNewBlockInMotion(e, block)}\r\n                    // handleDragEnd={e=>handleDragEnd(e,)}\r\n                    />\r\n                    {move === 'forward' && <ForwardBlock\r\n                        clickFunc={e => createNewBlock(e, move)}\r\n                        x={blockSize * index}\r\n                        y={Y_Block_selectOffsetRename}\r\n                    />}\r\n                    {move === 'left' && <LeftBlock\r\n                        clickFunc={e => createNewBlock(e, move)}\r\n                        x={blockSize * index}\r\n                        y={Y_Block_selectOffsetRename}\r\n                    />}\r\n                    {move === 'right' && <RightBlock\r\n                        clickFunc={e => createNewBlock(e, move)}\r\n                        x={blockSize * index}\r\n                        y={Y_Block_selectOffsetRename}\r\n                    />}\r\n                    {move === 'light' && <LightBlock\r\n                        clickFunc={e => createNewBlock(e, move)}\r\n                        x={blockSize * index}\r\n                        y={Y_Block_selectOffsetRename}\r\n                    />}\r\n                    {move === 'jump' && <SpringBlock\r\n                        clickFunc={e => createNewBlock(e, move)}\r\n                        x={blockSize * index}\r\n                        y={Y_Block_selectOffsetRename}\r\n                    />}\r\n                    {move === 'f1' && <Text\r\n                        fontSize={35}\r\n                        onClick={e => createNewBlock(e, move)}\r\n                        x={blockSize * index + 15}\r\n                        y={Y_Block_selectOffsetRename + 20}\r\n                        text={'F1'}\r\n                    />}\r\n                    {move === 'f2' && <Text\r\n                        fontSize={35}\r\n                        onClick={e => createNewBlock(e, move)}\r\n                        x={blockSize * index + 15}\r\n                        y={Y_Block_selectOffsetRename + 20}\r\n                        text={'F2'}\r\n                    />}\r\n                </Fragment>\r\n            )\r\n        })\r\n\r\n        return (\r\n            <Layer>\r\n                {moveSelection.length > 0 ?\r\n                    moveSelection\r\n                    : <Text text=\"No Blocks found for this level\" />\r\n                }\r\n            </Layer>\r\n        )\r\n    }\r\n    const memoizedMoveSelection = useMemo(() => createMoveSelection(!!foundLevel ? foundLevel.available_moves : []), [sectionName, levelID])\r\n    // drag block related\r\n    const updateBlockLocation = (e, id, newX, newY) => {\r\n        const [items, item, index] = findBlock(e, id)\r\n        items[index] = {\r\n            ...item,\r\n            i: calcI(newX),\r\n            j: calcJ(newY)\r\n        };\r\n        setMainBlocks(prev => items)\r\n    }\r\n    // drag block related\r\n    const handleDragStart = (e, id) => {\r\n        // TODO: this function should bring any currently dragging element and put it on top\r\n        // const [items, item, index] = findBlock(e, id)\r\n        // // remove from the list:\r\n        // items.splice(index, 1)\r\n        // // add to the top\r\n        // items.push(item)\r\n        // setMainBlocks(items)\r\n\r\n\r\n        // on every pick up of block, organize board\r\n        organizeBoard(e, id)\r\n    }\r\n    // drag block related\r\n    const handleDragEnd = (e, id) => {\r\n        // this code needs to be finished to update the blocks array when the drop happens\r\n        // updateBlockLocation(e, id, e.target.x(), e.target.y())\r\n        calculateDropLocation(e, id)\r\n    }\r\n    // drag block related\r\n    const calculateDropLocation = (e, id) => {\r\n        const mainBounds = {\r\n            left: offsetX,\r\n            right: offsetX + (blockSize * 4),\r\n            top: offsetY,\r\n            bottom: offsetY + (blockSize * 3)\r\n        }\r\n        const funcBounds = {\r\n            left: offsetX,\r\n            right: offsetX + (blockSize * 4),\r\n            top: offsetY,\r\n            bottom: offsetY + (blockSize * 3)\r\n        }\r\n\r\n        const dropX = (offsetX % 68) + Math.round(e.target.x() / blockSize) * blockSize\r\n        const dropY = offsetY + Math.round(e.target.y() / blockSize) * blockSize\r\n\r\n        // if drop location is out of bounds\r\n        if (((dropY + (blockSize / 2)) < mainBounds.top) ||\r\n            (dropY > (mainBounds.bottom + (blockSize / 2))) ||\r\n            ((dropX + (blockSize / 2)) < mainBounds.left) ||\r\n            (dropX > (mainBounds.right + (blockSize / 2)))\r\n        ) {\r\n            deleteSelf(e, id)\r\n        }\r\n        else {\r\n            // move block to new location\r\n\r\n            // if hover over no blocks, place block at the end of all the blocks\r\n            const lastBlockX = ((mainBlocks.length - 1) % 4) * blockSize + offsetX\r\n            const lastBlockY = Math.floor((mainBlocks.length - 1) / 4) * blockSize + offsetY\r\n            e.target.to({\r\n                x: lastBlockX,\r\n                y: lastBlockY\r\n            });\r\n            updateBlockLocation(e, id, lastBlockX, lastBlockY)\r\n\r\n            // if hover over existing block, replace block \r\n            // if hover in between existing blocks, place in between and move all blocks on the right, to the left\r\n            // e.target.to({\r\n            //     x: dropX,\r\n            //     y: dropY\r\n            // });\r\n        }\r\n    }\r\n    // block related\r\n    const findBlock = (e, id) => {\r\n        const items = [...mainBlocks]\r\n        const item = items.find(i => i.id === id)\r\n        const index = items.indexOf(item)\r\n        return [items, item, index]\r\n    }\r\n    // block related\r\n    const deleteSelf = (e, id) => {\r\n        resetRobot()\r\n        resetLevel()\r\n        organizeBoard(e, id)\r\n        if (activeGridLayer === 0) {\r\n            setMainBlocks(prevBlocks => prevBlocks.filter(obj => obj.id !== id))\r\n        }\r\n        else if (activeGridLayer === 1) {\r\n            setFunc1Blocks(prevBlocks => prevBlocks.filter(obj => obj.id !== id))\r\n        }\r\n    }\r\n    // board related\r\n    const organizeBoard = (e, id) => {\r\n        // confirm all blocks fit in screen correctly\r\n        if (activeGridLayer === 0) {\r\n            setMainBlocks(prevBlocks => {\r\n                const currentBlock = prevBlocks.find(b => b.id === id)\r\n                let newBlockArray = []\r\n                let foundBlock = false\r\n                for (let b of prevBlocks) {\r\n                    let newBlock = { ...b }\r\n                    if (currentBlock.i === b.i && currentBlock.j === b.j) {\r\n                        foundBlock = true\r\n                        // dont do anything here\r\n                        newBlockArray.push(newBlock)\r\n                    }\r\n                    else if (foundBlock) {\r\n                        // shift blocks\r\n                        if (newBlock.i === 0) {\r\n                            newBlock.i = 3\r\n                            if (newBlock.j !== 0) {\r\n                                newBlock.j--\r\n                            }\r\n                        }\r\n                        else {\r\n                            newBlock.i--\r\n                        }\r\n                        newBlockArray.push(newBlock)\r\n                    }\r\n                    else {\r\n                        // have not found block yet\r\n                        newBlockArray.push(newBlock)\r\n                    }\r\n                }\r\n                return newBlockArray.sort((b1, b2) => b1.j - b2.j || b1.i - b2.i)\r\n\r\n            })\r\n        }\r\n        else if (activeGridLayer === 1) {\r\n            setFunc1Blocks(prevBlocks => {\r\n                const currentBlock = prevBlocks.find(b => b.id === id)\r\n                let newBlockArray = []\r\n                let foundBlock = false\r\n                for (let b of prevBlocks) {\r\n                    let newBlock = { ...b }\r\n                    if (currentBlock.i === b.i && currentBlock.j === b.j) {\r\n                        foundBlock = true\r\n                        // dont do anything here\r\n                        newBlockArray.push(newBlock)\r\n                    }\r\n                    else if (foundBlock) {\r\n                        // shift blocks\r\n                        if (newBlock.i === 0) {\r\n                            newBlock.i = 3\r\n                            if (newBlock.j !== 0) {\r\n                                newBlock.j--\r\n                            }\r\n                        }\r\n                        else {\r\n                            newBlock.i--\r\n                        }\r\n                        newBlockArray.push(newBlock)\r\n                    }\r\n                    else {\r\n                        // have not found block yet\r\n                        newBlockArray.push(newBlock)\r\n                    }\r\n                }\r\n                return newBlockArray.sort((b1, b2) => b1.j - b2.j || b1.i - b2.i)\r\n            })\r\n        }\r\n    }\r\n    // board related\r\n    const resetBoard = (e) => {\r\n        resetRobot()\r\n        resetLevel()\r\n        setMainBlocks(prev => [])\r\n        setFunc1Blocks(prev => [])\r\n    }\r\n    // board related\r\n    const undoMove = (e) => {\r\n        resetRobot()\r\n        resetLevel()\r\n        if (activeGridLayer === 0) {\r\n            setMainBlocks(prevBlocks => {\r\n                let newBlocks = [...prevBlocks]\r\n                newBlocks.pop()\r\n                return newBlocks\r\n            })\r\n        }\r\n        else if (activeGridLayer === 1) {\r\n            setFunc1Blocks(prevBlocks => {\r\n                let newBlocks = [...prevBlocks]\r\n                newBlocks.pop()\r\n                return newBlocks\r\n            })\r\n        }\r\n    }\r\n    // robot related\r\n    const isLightable = ({ x, y, z }) => {\r\n        const currBlockIndex = levelData.findIndex(b => {\r\n            if (b.x === x && b.y === y && b.z === z) {\r\n                return b\r\n            }\r\n        })\r\n        if (levelData[currBlockIndex].type === moveTypes[1]) {\r\n            return currBlockIndex\r\n        }\r\n        return -1\r\n    }\r\n    // robot related\r\n    const canJump = ({ x, y, z }) => {\r\n        if (inRange({ x, y, z: z + 1 })) {\r\n            return 1\r\n        }\r\n        if (inRange({ x, y, z: z - 1 })) {\r\n            return -1\r\n        }\r\n        return 0\r\n    }\r\n    // robot related\r\n    const inRange = ({ x, y, z }) => {\r\n        // iterate through blocks and confirm newLocation is legal)\r\n        for (let block of levelData) {\r\n            if (block.x === x && block.y === y && block.z === z) {\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n    const redo = (e) => {\r\n        resetRobot()\r\n        setMainBlocks(prev => [])\r\n        setFunc1Blocks(prev => [])\r\n        resetLevel()\r\n        toggleModal()\r\n    }\r\n    // robot related\r\n    const updateRobotlocation = (block) => {\r\n        // TODO: finish this code\r\n        setRobotLocation(prevLocation => {\r\n            let currRobot = { ...prevLocation }//{ y 0, y: 0, z: 1, angle: 0 }\r\n            // on turn, update angle to face right\r\n            if (block.blockType === moveTypes[3]) {\r\n                switch (currRobot.angle) {\r\n                    case 0:\r\n                        currRobot.angle = 120\r\n                        break\r\n                    case 120:\r\n                        currRobot.angle = 180\r\n                        break\r\n                    case 180:\r\n                        currRobot.angle = 300\r\n                        break\r\n                    case 300:\r\n                        currRobot.angle = 0\r\n                        break\r\n                }\r\n            }\r\n            // on turn, update angle to face left\r\n            if (block.blockType === moveTypes[2]) {\r\n                switch (currRobot.angle) {\r\n                    case 0:\r\n                        currRobot.angle = 300\r\n                        break\r\n                    case 120:\r\n                        currRobot.angle = 0\r\n                        break\r\n                    case 180:\r\n                        currRobot.angle = 120\r\n                        break\r\n                    case 300:\r\n                        currRobot.angle = 180\r\n                        break\r\n                }\r\n            }\r\n            // on forward, update x or y based on angle\r\n            if (block.blockType === moveTypes[0]) {\r\n                // check if robot can indeed move forward here\r\n                if (currRobot.angle === 0 && inRange({ x: currRobot.x + 1, y: currRobot.y, z: currRobot.z })) {\r\n                    currRobot.x++\r\n                }\r\n                if (currRobot.angle === 120 && inRange({ x: currRobot.x, y: currRobot.y - 1, z: currRobot.z })) {\r\n                    currRobot.y--\r\n                }\r\n                if (currRobot.angle === 180 && inRange({ x: currRobot.x - 1, y: currRobot.y, z: currRobot.z })) {\r\n                    currRobot.x--\r\n                }\r\n                if (currRobot.angle === 300 && inRange({ x: currRobot.x, y: currRobot.y + 1, z: currRobot.z })) {\r\n                    currRobot.y++\r\n                }\r\n            }\r\n            // on jump, update z and x or y based on angle and jumpable location\r\n            if (block.blockType === moveTypes[4]) {\r\n                // check if robot can indeed move forward and jump up or down here\r\n\r\n                if (currRobot.angle === 0) {\r\n                    let jump = canJump({ x: currRobot.x + 1, y: currRobot.y, z: currRobot.z })\r\n                    if (jump !== 0) {\r\n                        currRobot.x++\r\n                        currRobot.z += jump\r\n                    }\r\n                }\r\n                if (currRobot.angle === 120) {\r\n                    let jump = canJump({ x: currRobot.x, y: currRobot.y - 1, z: currRobot.z })\r\n                    if (jump !== 0) {\r\n                        currRobot.y--\r\n                        currRobot.z += jump\r\n                    }\r\n                }\r\n                if (currRobot.angle === 180) {\r\n                    let jump = canJump({ x: currRobot.x - 1, y: currRobot.y, z: currRobot.z })\r\n                    if (jump !== 0) {\r\n                        currRobot.x--\r\n                        currRobot.z += jump\r\n                    }\r\n                }\r\n                if (currRobot.angle === 300) {\r\n                    let jump = canJump({ x: currRobot.x, y: currRobot.y + 1, z: currRobot.z })\r\n                    if (jump !== 0) {\r\n                        currRobot.y++\r\n                        currRobot.z += jump\r\n                    }\r\n                }\r\n            }\r\n            // on light, toggle powered value\r\n            if (block.blockType === moveTypes[1]) {\r\n                let index = isLightable({ x: currRobot.x, y: currRobot.y, z: currRobot.z })\r\n                if (index >= 0) {\r\n                    setLevelData(prevLevelData => {\r\n                        let newLevelData = [...prevLevelData]\r\n                        newLevelData[index].powered = !newLevelData[index].powered\r\n                        return newLevelData\r\n                    })\r\n                }\r\n            }\r\n            return currRobot\r\n        })\r\n    }\r\n    const checkSolution = () => {\r\n        for (let block of levelData) {\r\n            if (block.type === blockTypes[1]) {\r\n                if (!block.powered) {\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        // if we arrived here, the player has solved the level\r\n        // pop up modal, telling user that the player has successfully completed the level, to move on to the next level or to redo level\r\n        toggleModal()\r\n        // ask the user if they can refactor their solution to use less blocks if they used more than min needed\r\n        return true\r\n    }\r\n    // board related\r\n    const runPlayerCode = e => {\r\n        resetRobot()\r\n        resetLevel()\r\n        let i = 0\r\n        let checkingGame = setInterval(() => {\r\n            if (mainBlocks.length > 0) {\r\n                updateRobotlocation(mainBlocks[i])\r\n                i++\r\n                if (checkSolution() || i >= mainBlocks.length) {\r\n                    clearInterval(checkingGame);\r\n                }\r\n            }\r\n        }, timeInterval)\r\n    }\r\n    return (\r\n        <div className=\"p-2\">\r\n            {legalLevel ?\r\n                <>\r\n                    <Stage width={width - 200} height={height - 100}>\r\n                        {memoizedLevel}\r\n                        {memoizedMainGrid}\r\n                        {foundLevel.section_id > 0 && memoizedFuncGrid}\r\n                        {memoizedMoveSelection}\r\n                        {/* drag and drop blocks layer */}\r\n                        <Layer>\r\n                            {mainBlocks.map((b, index) => <CodeBlock\r\n                                {...b}\r\n                                x={calcX(b.i)}\r\n                                y={calcY(b.j)}\r\n                                key={index}\r\n                                index={index}\r\n                                deleteSelf={deleteSelf}\r\n                                calculateDropLocation={calculateDropLocation}\r\n                                handleDragStart={handleDragStart}\r\n                                handleDragEnd={handleDragEnd}\r\n                            />\r\n                            )}\r\n                            {func1Blocks.map((b, index) => <CodeBlock\r\n                                {...b}\r\n                                x={calcX(b.i)}\r\n                                y={calcY(b.j)}\r\n                                key={index}\r\n                                index={index}\r\n                                deleteSelf={deleteSelf}\r\n                                calculateDropLocation={calculateDropLocation}\r\n                                handleDragStart={handleDragStart}\r\n                                handleDragEnd={handleDragEnd}\r\n                            />\r\n                            )}\r\n                            <Rect\r\n                                onClick={resetBoard}\r\n                                x={blockSize * 0}\r\n                                y={450 - blockSize - 10}\r\n                                width={blockSize}\r\n                                height={blockSize}\r\n                                fill=\"red\"\r\n                            />\r\n                            <Rect\r\n                                onClick={undoMove}\r\n                                x={blockSize * 1}\r\n                                y={450 - blockSize - 10}\r\n                                width={blockSize}\r\n                                height={blockSize}\r\n                                fill=\"yellow\"\r\n                            />\r\n                            <Rect\r\n                                onClick={runPlayerCode}\r\n                                x={blockSize * 2}\r\n                                y={450 - blockSize - 10}\r\n                                width={blockSize}\r\n                                height={blockSize}\r\n                                fill=\"green\"\r\n                            />\r\n                            <Rect\r\n                                onClick={updateTimeInterval}\r\n                                x={blockSize * 3}\r\n                                y={450 - blockSize - 10}\r\n                                width={blockSize}\r\n                                height={blockSize}\r\n                                fill=\"purple\"\r\n                            />\r\n                        </Layer>\r\n                    </Stage>\r\n                    <Modal modal={modal} toggle={toggleModal} redo={redo} levelInfo={foundLevel} />\r\n                </>\r\n                : <Redirect to='/' />}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Game\r\n","/Users/awesomeinc/ainc/lightbot/src/components/sprites/ForwardBlock.js",[],"/Users/awesomeinc/ainc/lightbot/src/components/sprites/LeftBlock.js",[],"/Users/awesomeinc/ainc/lightbot/src/components/sprites/RightBlock.js",[],"/Users/awesomeinc/ainc/lightbot/src/components/sprites/LightBlock.js",["105","106"],"/Users/awesomeinc/ainc/lightbot/src/components/sprites/SpringBlock.js",["107","108"],{"ruleId":"109","replacedBy":"110"},{"ruleId":"111","replacedBy":"112"},{"ruleId":"109","replacedBy":"113"},{"ruleId":"111","replacedBy":"114"},{"ruleId":"115","severity":1,"message":"116","line":136,"column":111,"nodeType":"117","endLine":136,"endColumn":128,"suggestions":"118"},{"ruleId":"115","severity":1,"message":"116","line":138,"column":117,"nodeType":"117","endLine":138,"endColumn":134,"suggestions":"119"},{"ruleId":"120","severity":2,"message":"121","line":184,"column":61,"nodeType":"122","messageId":"123","endLine":184,"endColumn":62},{"ruleId":"115","severity":1,"message":"124","line":254,"column":118,"nodeType":"117","endLine":254,"endColumn":140,"suggestions":"125"},{"ruleId":"126","severity":1,"message":"127","line":293,"column":15,"nodeType":"122","messageId":"128","endLine":293,"endColumn":25},{"ruleId":"129","severity":1,"message":"130","line":449,"column":54,"nodeType":"131","messageId":"132","endLine":449,"endColumn":56},{"ruleId":"133","severity":1,"message":"134","line":493,"column":17,"nodeType":"135","messageId":"136","endLine":506,"endColumn":18},{"ruleId":"133","severity":1,"message":"134","line":510,"column":17,"nodeType":"135","messageId":"136","endLine":523,"endColumn":18},{"ruleId":"137","severity":1,"message":"138","line":64,"column":17,"nodeType":"139","endLine":64,"endColumn":31},{"ruleId":"137","severity":1,"message":"138","line":65,"column":17,"nodeType":"139","endLine":65,"endColumn":37},{"ruleId":"126","severity":1,"message":"140","line":2,"column":21,"nodeType":"122","messageId":"128","endLine":2,"endColumn":27},{"ruleId":"137","severity":1,"message":"138","line":30,"column":17,"nodeType":"139","endLine":30,"endColumn":31},"no-native-reassign",["141"],"no-negated-in-lhs",["142"],["141"],["142"],"react-hooks/exhaustive-deps","React Hook useMemo has a missing dependency: 'createGridLayer'. Either include it or remove the dependency array.","ArrayExpression",["143"],["144"],"no-undef","'j' is not defined.","Identifier","undef","React Hook useMemo has missing dependencies: 'createMoveSelection' and 'foundLevel'. Either include them or remove the dependency array.",["145"],"no-unused-vars","'funcBounds' is assigned a value but never used.","unusedVar","array-callback-return","Array.prototype.findIndex() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","react/jsx-no-duplicate-props","No duplicate props allowed","JSXAttribute","'colors' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"146","fix":"147"},{"desc":"146","fix":"148"},{"desc":"149","fix":"150"},"Update the dependencies array to be: [createGridLayer]",{"range":"151","text":"152"},{"range":"153","text":"152"},"Update the dependencies array to be: [createMoveSelection, foundLevel]",{"range":"154","text":"155"},[5974,5991],"[createGridLayer]",[6112,6129],[11289,11311],"[createMoveSelection, foundLevel]"]